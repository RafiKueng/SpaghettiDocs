\subsection{Server}
\label{sec:server}

\subsubsection{Usecase}
The application server needs to manage all the data needed and generated by the client app.
It has to keep track of lenses, that can be modeled (\T{LensData}) objects and created models (\T{ModellingResult} objects).

The application server provides the client unified access to survey images hosted on several possible external data sources (at the moent, spacewarps and masterlens are implemented). It needs to assign each image a unique ID to be able to keep track of it.

Additionaly, it has to keep track which results are for which model, which user created the results and which results are descendants from each other.
This is a typical application for a data base.
The server manages a database and guarrantees its consitency.

Additionally, it is the interface between the client app and the worker application, that does the actual modeling. It has to convert the data generated by the client (JSON) to a format that the modeling application requires (GLASS config files).
Further, once a model / result is simulated, the server creates figures and sends them back to the client for display.



\subsubsection{Techniques used}

The server is implemented in Python language, using the Django framework. The framework are served using gunicorn, a WSGI HTTP server implemented in Python.

The framework Django follows a model-view-controller architecture.
It defines a data model which is represented in a relational data base.
A view is a representation of a subset of this data presented to a user (the client app in this case).
The user can use a controller, to manipulate the data model.

The data model is defined by defining Python classes (\befn{ModellerApp/models.py}). Django uses a relational database in the backend, to keep track of all the created instances of those models.

Views and controllers are defined by Python functions (\befn{ModellerApp/views.py}).
Those functions get mapped to HTTP requests by \befn{lmt/urls.py}.
They process a request and either query the model / database to return a representation of the data or update the data.

For the actual storage of the data, Django relies on a external relational database.
For \spl, the de facto standard mySQL was chosen.

Django offers a powerful template system, that allows to render the data in any possible form.
Usually it's used to render html pages, but this setup uses it to return JSON data obejcts to the client app.
The template system is used to render the result views\footnote{\splurl[data/<result_id>]}, which can be accessed directly by a browser to display generated models.

To simulate the models, the server needs to connect to the simulation software (GLASS), tell it what to do and fire it up.
The server creates a config file for GLASS for each request, and then starts an instance of GLASS running this file.
Since the simulation takes in the order of minutes, the server worker process should not be blocked during simulation.
Additionally, this part should be easily scalable, since it creates the biggest server load and needs to be up scaled linearly with the amount of users that use \spl concurrently.
This is done using a task distribution system (Celery), that gets introduced in \secref{worker}.







\subsubsection{The Design of the API}


\uml[width=1\textwidth]{serverapi_full}{An overview over the server API and the internal functions called. Shows the origin of requests with green background. The caching proxy with blue background. Entry points / controller definitions with yellow background. Server list of server function with white background. Lines show flow of data (function calls, HTML requests) Dashed blue and red function calls and grey functions will be removed in future versions (no valid UML notation)}



\Umlref{serverapi_full} shows a complete overview of the server API.
Note that the API is currently under redesign.
The old design paradigm stated, that each possible action of the server was exposed direcly to an url, where a client could make a HTTP request to. This assignment is confiured in \befn{lmt/urls.py}.
It has the draw back, that those access points need to be configured on the server side in two places, in the server application, and additionally in the proxy.

The new design paradigm, there are only three access points offered. this simplifies the administration of the proxy server and increases the flexibility of the application.




\subsubsection{}
