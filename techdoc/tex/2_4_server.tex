\subsection{Server}
\label{sec:server}

\subsubsection{Usecase}
The application server needs to manage all the data needed and generated by the client app.
It has to keep track of lenses, that can be modeled (\T{LensData}) objects and created models (\T{ModellingResult} objects).

The application server provides the client unified access to survey images hosted on several possible external data sources (at the moent, spacewarps and masterlens are implemented). It needs to assign each image a unique ID to be able to keep track of it.

Additionaly, it has to keep track which results are for which model, which user created the results and which results are descendants from each other.
This is a typical application for a data base.
The server manages a database and guarrantees its consitency.

Additionally, it is the interface between the client app and the worker application, that does the actual modeling. It has to convert the data generated by the client (JSON) to a format that the modeling application requires (GLASS config files).
Further, once a model / result is simulated, the server creates figures and sends them back to the client for display.



\subsubsection{Techniques used}

The server is implemented in Python language, using the Django framework. The framework are served using gunicorn, a WSGI HTTP server implemented in Python.

The framework Django follows a model-view-controller architecture.
It defines a data model which is represented in a relational data base.
A view is a representation of a subset of this data presented to a user (the client app in this case).
The user can use a controller, to manipulate the data model.

The data model is defined by defining Python classes (\befn{ModellerApp/models.py}). Django uses a relational database in the backend, to keep track of all the created instances of those models.

Views and controllers are defined by Python functions (\befn{ModellerApp/views.py}).
Those functions get mapped to HTTP requests by \befn{lmt/urls.py}.
They process a request and either query the model / database to return a representation of the data or update the data.

For the actual storage of the data, Django relies on a external relational database.
For \spl, the de facto standard mySQL was chosen.

Django offers a powerful template system, that allows to render the data in any possible form.
Usually it's used to render html pages, but this setup uses it to return JSON data obejcts to the client app.
The template system is used to render the result views\footnote{\splurl[data/<result_id>]}, which can be accessed directly by a browser to display generated models.

To simulate the models, the server needs to connect to the simulation software (GLASS), tell it what to do and fire it up.
The server creates a config file for GLASS for each request, and then starts an instance of GLASS running this file.
Since the simulation takes in the order of minutes, the server worker process should not be blocked during simulation.
Additionally, this part should be easily scalable, since it creates the biggest server load and needs to be up scaled linearly with the amount of users that use \spl concurrently.
This is done using a task distribution system (Celery), that gets introduced in \secref{worker}.







\subsubsection{The Design of the API}


\uml[width=1\textwidth]{serverapi_full}{An overview over the server API and the internal functions called. Shows the origin of requests with green background. The caching proxy with blue background. Entry points / controller definitions with yellow background. Server list of server function with white background. Lines show flow of data (function calls, HTML requests) Dashed blue and red function calls and grey functions will be removed in future versions (no valid UML notation)}



\Umlref{serverapi_full} shows a complete overview of the server API.
Note that the API is currently under redesign.
The old design paradigm stated, that each possible action of the server was exposed direcly to an url, where a client could make a HTTP request to. This assignment is confiured in \befn{lmt/urls.py}.
It has the draw back, that those access points need to be configured on the server side in two places, in the server application, and additionally in the proxy.

The new design paradigm, there are only three access points offered. this simplifies the administration of the proxy server and increases the flexibility of the application.




\subsubsection{The Design of the Database}


\uml{db}{UML database schema. Using Django notation for field types.}

The database schema is shown in \umlref{db}.
There are two important tables in the database.
The first is the table of all lenses, that have been modeled, \dbtable{LensData}.
It stores all the objects from all different data sources, as soon as they have been requested once.
It keeps track of the origin of the image in the field \dbfield{datasource}.
The location of the image files is stored in \dbfield{img\_data}, as a JSON string.
This JSON object needs at least a key \T{url}, pointing to a publically available image.
If an lens consists of multiple images (multiple filters / bands...), those can be stored in this JSON object too.\footnote{to be implemented in the client side.}
Arbitrary additional data (for use in the corresponding datasource modules client and server side) can be stored as JSON strings in \dbfield{add\_data}.

The second table, \dbtable{ModellingResult}, keeps track of all the models, that were generated.
It keeps track of the \dbtable{LensData}, it is a result of and stores the JSON string generated by the client, that represents this model in \dbfield{json\_str}.
If this result is a refined version of a previous, the key of the previous is saved in \dbfield{parent\_result}, creating a tree like structure.
Additional administration information is kept in \dbfield{created\_by}, \dbfield{rendered\_last}, \dbfield{last\_accessed}.
This information can be used for later clean up purposes as the deletion of the modeling state files and rendered images for models that are not visited anymore.
GLASS parameters used to generate the model are stored in the according fields.


\subsubsection{The parsing of a model JSON string}

In order to save a received model from the client app, the server parses the JSON string received and converts it to a temporarily python data structure.
This is done in \befn{ModellerApp/utils.py}, using the class \C{EvalAndSaveJSON}.

\F{EvalAndSaveJSON.__init__()} first sets all the default values for glass and then calls \F{EvalAndSaveJSON.evalModelString()}.
This function parses the JSON model string to a python dict containing Python objects.
The parameters of the uploaded model are then, after a sanity check, written over the default values.

In a second step, \F{EvalAndSaveJSON.orderPoints2()} reorders the tree like structure of extremal points provided by the client to a list of images ordered by their expected arrival time. It determins the center of the lensing galaxy (assumed to be the maximum) This also converts all the measurements from \spl pixels to actual arcsecs and makes them reative to the center of the lens.

The third step \F{EvalAndSaveJSON.createModellingResult()} creates the database entry in \dbtable{ModellingResult}.
At the end, the last step \F{EvalAndSaveJSON.createConfigFile()} creates the GLASS config file to be supplied to the modelling software.










