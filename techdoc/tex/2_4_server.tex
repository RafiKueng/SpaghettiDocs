\subsection{Server-side Scripts (Server)}
\label{sec:server}

As explained in \secref{serverside}, the server application is basically an interface to the database.
\spl splits the server-side scripts further up and distinguishes between the module that manages data (server) and the part that generates data (worker) that is introduced in \secref{worker}.

The server manages all the data needed and generated by the client app.
It keeps track of lenses that can be modeled (\T{LensData} objects identified by \T{model_id}\footnote{Will be renamed to \T{lens_id}.}), create new ones from the data sources available, created models (\T{ModellingResult} objects, identified by \T{result_id}) and keeps track of simulation results and files.

The server provides the client unified access to survey images hosted on several possible external data sources (at the moment, \sw is fully and \ml partially implemented).
It keeps track which models (results) belong to which lens, which user created a model and which models are descendants from each other.

Additionally, it is the interface between the client app and the workers that do the actual modeling.
It has to convert the data generated by the client (JSON) to a format that the modeling application requires (GLASS config files).


\subsubsection{Techniques used}

The server is implemented in Python language, using the Django framework.
The framework is served using gunicorn, a WSGI HTTP server implemented in Python.

The Django framework follows a ``model-view-controller'' architecture.
It defines a data model which is represented in a backend database.
A ``view'' is a representation of a subset of this data presented to a user (the client app in this case).
The ``controller'' allows to modify the data.

The data model is created by defining Python classes in \befn{ModellerApp/models.py}.
Django uses a relational database in the backend, to keep track of all the created instances of those models.
For the actual storage of the data, Django relies on a external relational database.
For \spl, MySQL, the most popular\cite{dbranking} open source database, was chosen.

Views and controllers are defined by Python functions (\befn{ModellerApp/views.py}).
Those functions get mapped to HTTP requests by \befn{lmt/urls.py}.
They process a request and either query the model / database in order to return a representation of the data or update the data.



Django offers a powerful template system that allows to render the data in any possible form.
Usually it's used to render HTML pages, but this setup uses it to return JSON data objects to the client app.
The template system is used to render the result views\footnote{\splurl[data/<result_id>]}, which can be accessed directly by a browser to display generated models.

In order to simulate the models, the server needs to connect to GLASS, the simulation software, tell it what to do and fire it up.
The server creates a config file for GLASS for each request, and then starts an instance of GLASS running this file.
Since the simulation takes in the order of minutes, the server worker process should not be blocked during simulation.
Additionally, this part should be easily scalable, since it creates the biggest server load and needs to be scaled up linearly with the amount of users that use \spl concurrently.
This is done using a task distribution system (Celery) that will be introduced in \secref{worker}.







\subsubsection{The Design of the API}


\uml[width=1\textwidth]{serverapi_full}{An overview over the server API and the internal functions.\\Green background: origin of requests. Blue background: caching proxy. Yellow background: API (controller definitions). White background: internal functions. Grey background: functions to be removed in future versions.\\Lines show flow of data (function calls, HTML requests).}



\Umlref{serverapi_full} shows a complete overview of the server API.
Note that the API is currently under redesign.
The old design paradigm stated that each possible action of the server was exposed directly to an URL, where a client could make a HTTP request to. This assignment is configured in \befn{lmt/urls.py}.
It has the draw back that those access points need to be configured on the server side in two places, in the server application, and additionally in the proxy.

In the new design paradigm, there are only three access points offered. This simplifies the administration of the proxy server and increases the flexibility of the application.




\subsubsection{The Design of the Database}


\uml{db}{UML database schema. Using Django notation for field types.}

The database schema is shown in \umlref{db}.
There are two important tables in the database.
The first is the table of all lenses that have been modeled: \dbtable{LensData}.
It stores all the objects from all different data sources, as soon as they have been requested once.
It keeps track of the origin of the image in the field \dbfield{datasource}.
The location of the image files is stored in \dbfield{img\_data}, as a JSON string.
This JSON object needs at least a key \T{url}, pointing to a publically available image.
If a lens consists of multiple images (multiple filters / bands...), those can be stored in this JSON object too.\footnote{to be implemented in the client side.}
Arbitrary additional data (to be used in the corresponding datasource modules client and server side) can be stored as JSON strings in \dbfield{add\_data}.

The second table, \dbtable{ModellingResult}, keeps track of all the models that were generated.
It keeps track of the \dbtable{LensData}, of which it is a result and stores the JSON string generated by the client that represents this model in \dbfield{json\_str}.
If this result is a refined version of a previous one, the key of the previous one is saved in \dbfield{parent\_result}, which creates a tree-like structure.
Additional administration information is kept in \dbfield{created\_by}, \dbfield{rendered\_last}, \dbfield{last\_accessed}.
This information can be used for later clean up purposes`, like the deletion of the modeling state files and rendered images for models that are not visited anymore.
GLASS parameters used to generate the model are stored in the according fields.


\subsubsection{The parsing of a model JSON string}

In order to save a received model from the client app, the server parses the JSON string received and converts it to a temporarily Python data structure.
This is done in \befn{ModellerApp/utils.py}, using the class \C{EvalAndSaveJSON}.

\F{EvalAndSaveJSON.__init__()} first sets all the default values for glass and then calls \F{EvalAndSaveJSON.evalModelString()}.
This function parses the JSON model string to a Python dict containing Python objects.
The parameters of the uploaded model are then, after a sanity check, written over the default values.

In a second step, \F{EvalAndSaveJSON.orderPoints2()} reorders the tree-like structure of extremal points provided by the client to a list of images ordered by their expected arrival time. It determines the center of the lensing galaxy (assumed to be the maximum). This also converts all the measurements from \spl pixels to actual arcsec and makes them relative to the center of the lens.

The third step \F{EvalAndSaveJSON.createModellingResult()} creates the database entry in \dbtable{ModellingResult}.
The last step \F{EvalAndSaveJSON.createConfigFile()} creates the GLASS config file to be supplied to the modeling software.


\codep[2]{glass_cfg.py}{GLASS config file}








