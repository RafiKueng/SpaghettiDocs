\subsection{Client-side Application (Client)}
\label{sec:client}

The client-side application (client) was programmed using a modular, strict object oriented, event driven approach.
The four main parts of the client application are the Engine Core (engine), the User Interface (UI), the Application State (state) and the Communication Interface (com).
\Figref{client} shows the clients modules and according JS object namespaces.

\fig{client}{Modules of the client-side application and according JS namespaces}

The object oriented paradigm states, that each actor and data object is represented as an JS object.
Any data is stored inside a JS object, that offers methods to access and manipulate the internal state.

Event driven paradigm implies that the program flow is established using messages, called events.
Those can be fired by any object, called the event source (the UI\footnote{click on button} or the com\footnote{received data}).
Event handlers (also known as listener, receiver, observer) are objects that react to a certain event.
The main loop of the program, the event engine, takes care of detecting events and calling assigned handlers.
Any object can be event source and handler at the same time.


\subsubsection{Engine}



\subsubsection{User Interface}


\subsubsection{User Interface Layout}

\fig{ui}{User Interface. Depicting input area (yellow dashed left), output area (orange dashed right), general input (toolbar, green dotted) and two help areas (magenta dot dashed, top mouse-over help, bottom static help window).}



\subsubsection{State}

\subsubsection{Com}





\code{jquery_vs_js.js}{Comparing the modification of some objects, done in jQuery and pure js.}

\code{js-lmt.events_part.js}{An exerpt from \fjs{events}}

\uml[width=1\textwidth]{model}{Class diagram of a model. Only important attributes and methods are shown.}



%
%\subsubsection{Visual Layout}
%\label{sec:client_vis_layout}
%
%The User Interface was designed to be as simple as possible.
%It should hide away all settings that are not needed by default.
%To be self explanatory is almost impossible given the problem.
%Users will need to see a tutorial anyways.
%
%The basic degin idea was to provide a visual feedback and easy comparison between the input modelling parameter and the resulting output model.
%This is accived by putting the input area and output area side by side.
%All the functions that the user needs to manipulate the input are arranged on top of it, everything manipulating the output above the output window.
%A few general commands are arranged in a top bar.
%
%To assist the user, two systems are present: A exhaustive mouse over hoover tooltip help that pops up any relevant information for an tool / button under the cursor.
%This provides a short description of the action, and possibly a link to athe tutorial page.
%
%Additionally, there is a help bar at the bottom. This can be hidden from the toolbar.
%It also provides information about objects in the input area.
%mouse over tooltips would not function in the input area well, obstructing the users view over the model, hence this two folded helping system.
%
%For clients with a small screen, like mobile devices and possibly tables, the layout changes to only display the input or the output. The user can slide between those to sides using a slider.\footnote{Note that mobiles weren't tested and are not officially supported yet.}
%
%
%\subsubsection{Programm Layout}
%\label{sec:client_prog_layout}
%
%The client side application was programmed with a strict object oriented and event driven perspective.
%Instead of a regular program that has a main loop, that runs infinitly and where subfunctions are called, a event driven program is at halt when idle, and reacts to event that can be fired by any source (example: a key press triggers a function, instead of looping infinitely and checking if any key was pressed.)
%This is a very simplified abstraction\footnote{and technically not entirely true, there is an main loop that checks if events happend and then a dispacher calls the registered function.} but describes the situation of running JavaScript in a browser quite well.
%
%Everything is a object. The toolbar, the model, a dialogue screen.
%All objects can fire events and react to events and thus change their internal state, and/or fire a subsequent event.
%
%There are unique objects (like toolbar, input area), instances of prototype objects\footnote{in other programming languages prototype objects are called classes} and plain objects, that are a collection of keys and values\footnote{would be called dict in python or map in c++}. There can be more than one instance of a prototype object (for example Extremal Points, Point masses...)
%
%The main part of \spl is the object \lmt{events}; \lstref{js-lmt.events_part.js} shows an excerpt. This object registers at startup, which objects react with witch object functions (event handlers) on what events and thus, \lmt{events} defines all events possible (except a few standard events).
%
%\code{js-lmt.events_part.js}{An exerpt from \fjs{events}}
%
%There are basically three groups of objects that interact with each other: The user interface objects (\lmt{ui}, split in \lmt{ui.svg}, \lmt{ui.out}, \lmt{ui.html}), the communications object (\lmt{com}) and the current model (\lmt{model}, an instance of \lmto{model}).
%
%A model consists of an array of sources, an array of external masses (instances of \lmto{ExternalMass}) and a plain object \C{Parameters}.
%Each source is represented by an tree structure of instances of \C{ExtremalPoint} (\lmto{ExtremalPoint}).
%ExtremalPoints can be of a certain type (\str{min}, \str{max}, \str{sad}).
%They can be split up (and therefore be a saddlepoint by definition) and have two child ExtremalPoints.
%Each ExtremalPoint can have a Contourline (LMT.objects.contour) that goes around him (and therefore go through the parent ExtremalPoint).
%A contourline is modelled as a bézier curve and consits of contour points (LMT.objects.contourpoint), that represent the cotrolpoints of the bézier curve. See \umlref{model} for an overview.
%
%Additionally, there is an action stack (\lmt{actionstack}), \lmt{datasource}, \lmt{datasources}
%and some plainobjects that only store common data / functions that needs to be accessed by multiple objects (\lmt{modelData}, \C{LMT.settings}, \lmt{simulationResult}, \lmt{utils})
%
%
%\uml[width=1\textwidth]{model}{Class diagram of a model. Only important attributes and methods are shown.}
%
%
%The program is always in a certain state, defined through the attributes of all the objects.
%In \spl, the state consists of the state of the model, and the state of the ui.
%
%The state of the model (and all it's dependencies) can be parsed to a JSON\footnote{javascript object notation} string using the models \M{getStateAsString()} method.
%Vice versa, such a string can be converted to a model using the models abstract \M{getModelFronJSONStr(str)} function. (followed by a call to \M{update()} and \M{paint()})
%This mechanism is used to save models states in the action stack for undo and redo purposes, and to send them to the server side for simulation.
%
%
%The user interface \lmt{ui} consist of three subclasses \lmt{ui.html}, \lmt{ui.svg}, \lmt{ui.out}.
%
%\lmt{ui.svg} handles the input window. This part is implemented in SVG\footnote{scalable vector graphics}. SVG is a markup language, simmilar to HTML, that describes how to paint an image. It's elements are stored in a DOM and can easily be equipped with event handles (like \F{onClick}) and be manipulated.
%
%The background image(s) are, once loaded by \lmt{com}, rendered onto a HTML \T{canvas}.
%Several different filter images can be blended together, and adjustments to contrast and brightness can be done.
%Once rendered, the final background image is loaded as an \C{SVGimage} object into the SVG DOM. JavaScript objects representing user input like ExtremalPoints create corresponding figures in this DOM and keep them updated.
%
%The output pane \lmt{ui.out} consists of a set of HTML5 canvases lying on top of each other.
%Each image that the server generated through simulating the model gets rendered on one.
%Image adjustments (brightness, contrast) are done on the canvas as per pixel operations. \lmt{ui.out} brings the canvas that should be shown on top of teh others (by adjusting it's CSS z-level value).
%
%\lmt{ui.html} takes care of all other things. Especially it handles all pop-up windows, dialog screens and tool bars.
%This uses heavily the features of jQuery UI, to show and hide the elements in the HTML DOM that represent the dialog boxes.
%
%
%
%The communication with the server is handled by the \lmt{com} object.
%This is a collection of event handler function objects, that send and get data to the server in the background using the interface described in \secref{iface_c_s}.
%
%Upon receiving data, it is stored and then the app is notified by firing the according event. Receiving data is implemented with pulling. (A web server has no means of initiating a data transfer to a particular client) Pulling describes the technique of repeatedly querying the server, if new data is around.
%
%
%Data sources modules
%
%\spl can load it's data from different data sources.
%Those data sources are implemented as member objects of the plain object \lmt{datasources}.
%Each data source object has a corresponding server side class.
%Data source objects are initialized if selected in the initial dialog.
%They are supposed to populate \lmt{datasource} with their data and can make use of \lmt{ui.html.GenericDatasourceDialog}, that gets designed by the server side template.
%
%They have to register an event handler for \evt{LensesSelected}.
%This event gets fired, when the user clicks on OK in the custom \C{GenericDatasourceDialog}.
%The event handler can be used to determine the database model id in combination with the server side part of the data source module (by either creating a new database entry or returning an existing one). This communication bypasses the \lmt{com} object and uses its own api \T{datasourceApi}.
%Once the id of the model to be loaded is determined, the data source module is expected to return control to the main app by firing \evt[models]{GetModelData}, where \str{models} is an array of model ids to load.
%
%Alternatively, this process can be skipped by starting up the web application with a known, existing model id using \T{GET} parameter \T{mid}\footnote{\splurl[?mid=42]} or by loading an existing result using the result id \T{GET} parameter \T{rid}\footnote{\splurl[?rid=1337]}.
%
%
%
