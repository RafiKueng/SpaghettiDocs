\subsection{Client-side Application (Client)}
\label{sec:client}



\subsubsection{Engine}


\subsubsection{User Interface}


\subsubsection{User Interface Layout}


\subsubsection{State}

\subsubsection{Com}





\code{jquery_vs_js.js}{Comparing the modification of some objects, done in jQuery and pure js.}

\code{js-lmt.events_part.js}{An exerpt from \fjs{events}}

\uml[width=1\textwidth]{model}{Class diagram of a model. Only important attributes and methods are shown.}






%\subsection{Client-side Apllication (Client)}
%\label{sec:client}
%
%
%
%\subsubsection{Techniques}
%\label{sec:client_techniques}
%
%
%
%In webapp programming, is basically an interactive webpage, that communicates with other components.
%
%To accive that, you need 3 technologies: html, css and javascript. This is a unique standart.
%
%HTML describes the logical structre and data of your webpage, the userinterface. That elements are on the page.
%
%CSS defines the visuals, optics. how those elements defined by HTML are displayed. How those elements on the page look like
%
%Javascript (js) is the programming language, that runs on the client computer and thus defines the behavior. It describes, how the elements interact with each other.
%
%HTML defines the structure and the data of the page, css the optics and layout, and Js the behavior.
%
%
%\spl was designed to do as much computation as possible on the client side.
%This removes the load on the application server, network traffic and leads to a more natural feeling.
%The app responds instantaniouly to user inputs (instead of having to wait for a server response).
%Drawback: you have less control over data (saving snapshots) since browser are usually encapsulated from the rest of the computer, difficult to save status / data client side.
%
%
%An interactive webpage / user interface needs javascript for document object model (DOM, the tree of html attributes describing the structre of the webpage) manupulation.
%\spl consists of a single website.
%In opposite to most classical websites, where you click a link and load another page to react to user input, \spl is only one single page, that updates it's strucrte live as the user interacts with the page (called DHTML, dynamic HTML).
%Thus a dhtml webpage resembles more a classical desktop application than a classical website.
%
%If your DHTML site needs to exchange information with a server (e.g. to do some heavy calculations, store and retrieve data from a central database) you get Ajax (Asynchronous JavaScript and XML).
%
%
%
%
%ECMAScript (aka JavaScript)
%
%
%The modern webapp has thus 4 components: user input, output, intelligence, communications.
%All of which is programmed in javascript.
%Since this is a very common task, there are several libraries implemented in javascript, that facilitate the DOM manipulation (and thus creating a user interface).
%
%For \spl the the most common one was chosen, jQuery.
%It is used by two thirds of the top 10'000 webpages.
%It is open source and due to it's widespread use, it guarantees to be kept up to date and get often bugfixes.
%
%jQuery offers several addons, one of them jQuery UI, that facilitates the einheitliches design of user interfaces
%
%basically, jquery makes it easy to find, access and modify elements in the DOM, as shows \lstref{jquery_vs_js.js}. You can use CSS selectors to get DOM elements.
%
%\code{jquery_vs_js.js}{Comparing the modification of some objects, done in jQuery and pure js.}
%
%
%
%
%HTML
%
%There are two versions of html: the actual version 4.01, which almost anything that is connected to the internet is compatible to, probably even you toaster. Version 4 is around since Dec. 1998.
%
%And the next generation HTML5, that is currently in developpent (First working draft from Jan 2008).
%It offers many new features, for audio, video and graphics (canvas), communications (websockets), local storage.
%But is only supported by newer Web Browser and thus a smaller user base.
%
%Never the less we decided to go for html5. Because if offers the canvas and svg, two essential techniques explaned later for a web app.
%Since our expected user base will origin from galaxzoo and \sw, and those sites are also programmed in HTML5, we could expect our users to have up to date browsers.
%
%
%
%\subsubsection{Visual Layout}
%\label{sec:client_vis_layout}
%
%The User Interface was designed to be as simple as possible.
%It should hide away all settings that are not needed by default.
%To be self explanatory is almost impossible given the problem.
%Users will need to see a tutorial anyways.
%
%The basic degin idea was to provide a visual feedback and easy comparison between the input modelling parameter and the resulting output model.
%This is accived by putting the input area and output area side by side.
%All the functions that the user needs to manipulate the input are arranged on top of it, everything manipulating the output above the output window.
%A few general commands are arranged in a top bar.
%
%To assist the user, two systems are present: A exhaustive mouse over hoover tooltip help that pops up any relevant information for an tool / button under the cursor.
%This provides a short description of the action, and possibly a link to athe tutorial page.
%
%Additionally, there is a help bar at the bottom. This can be hidden from the toolbar.
%It also provides information about objects in the input area.
%mouse over tooltips would not function in the input area well, obstructing the users view over the model, hence this two folded helping system.
%
%For clients with a small screen, like mobile devices and possibly tables, the layout changes to only display the input or the output. The user can slide between those to sides using a slider.\footnote{Note that mobiles weren't tested and are not officially supported yet.}
%
%
%\subsubsection{Programm Layout}
%\label{sec:client_prog_layout}
%
%The client side application was programmed with a strict object oriented and event driven perspective.
%Instead of a regular program that has a main loop, that runs infinitly and where subfunctions are called, a event driven program is at halt when idle, and reacts to event that can be fired by any source (example: a key press triggers a function, instead of looping infinitely and checking if any key was pressed.)
%This is a very simplified abstraction\footnote{and technically not entirely true, there is an main loop that checks if events happend and then a dispacher calls the registered function.} but describes the situation of running JavaScript in a browser quite well.
%
%Everything is a object. The toolbar, the model, a dialogue screen.
%All objects can fire events and react to events and thus change their internal state, and/or fire a subsequent event.
%
%There are unique objects (like toolbar, input area), instances of prototype objects\footnote{in other programming languages prototype objects are called classes} and plain objects, that are a collection of keys and values\footnote{would be called dict in python or map in c++}. There can be more than one instance of a prototype object (for example Extremal Points, Point masses...)
%
%The main part of \spl is the object \lmt{events}; \lstref{js-lmt.events_part.js} shows an excerpt. This object registers at startup, which objects react with witch object functions (event handlers) on what events and thus, \lmt{events} defines all events possible (except a few standard events).
%
%\code{js-lmt.events_part.js}{An exerpt from \fjs{events}}
%
%There are basically three groups of objects that interact with each other: The user interface objects (\lmt{ui}, split in \lmt{ui.svg}, \lmt{ui.out}, \lmt{ui.html}), the communications object (\lmt{com}) and the current model (\lmt{model}, an instance of \lmto{model}).
%
%A model consists of an array of sources, an array of external masses (instances of \lmto{ExternalMass}) and a plain object \C{Parameters}.
%Each source is represented by an tree structure of instances of \C{ExtremalPoint} (\lmto{ExtremalPoint}).
%ExtremalPoints can be of a certain type (\str{min}, \str{max}, \str{sad}).
%They can be split up (and therefore be a saddlepoint by definition) and have two child ExtremalPoints.
%Each ExtremalPoint can have a Contourline (LMT.objects.contour) that goes around him (and therefore go through the parent ExtremalPoint).
%A contourline is modelled as a bézier curve and consits of contour points (LMT.objects.contourpoint), that represent the cotrolpoints of the bézier curve. See \umlref{model} for an overview.
%
%Additionally, there is an action stack (\lmt{actionstack}), \lmt{datasource}, \lmt{datasources}
%and some plainobjects that only store common data / functions that needs to be accessed by multiple objects (\lmt{modelData}, \C{LMT.settings}, \lmt{simulationResult}, \lmt{utils})
%
%
%\uml[width=1\textwidth]{model}{Class diagram of a model. Only important attributes and methods are shown.}
%
%
%The program is always in a certain state, defined through the attributes of all the objects.
%In \spl, the state consists of the state of the model, and the state of the ui.
%
%The state of the model (and all it's dependencies) can be parsed to a JSON\footnote{javascript object notation} string using the models \M{getStateAsString()} method.
%Vice versa, such a string can be converted to a model using the models abstract \M{getModelFronJSONStr(str)} function. (followed by a call to \M{update()} and \M{paint()})
%This mechanism is used to save models states in the action stack for undo and redo purposes, and to send them to the server side for simulation.
%
%
%The user interface \lmt{ui} consist of three subclasses \lmt{ui.html}, \lmt{ui.svg}, \lmt{ui.out}.
%
%\lmt{ui.svg} handles the input window. This part is implemented in SVG\footnote{scalable vector graphics}. SVG is a markup language, simmilar to HTML, that describes how to paint an image. It's elements are stored in a DOM and can easily be equipped with event handles (like \F{onClick}) and be manipulated.
%
%The background image(s) are, once loaded by \lmt{com}, rendered onto a HTML \T{canvas}.
%Several different filter images can be blended together, and adjustments to contrast and brightness can be done.
%Once rendered, the final background image is loaded as an \C{SVGimage} object into the SVG DOM. JavaScript objects representing user input like ExtremalPoints create corresponding figures in this DOM and keep them updated.
%
%The output pane \lmt{ui.out} consists of a set of HTML5 canvases lying on top of each other.
%Each image that the server generated through simulating the model gets rendered on one.
%Image adjustments (brightness, contrast) are done on the canvas as per pixel operations. \lmt{ui.out} brings the canvas that should be shown on top of teh others (by adjusting it's CSS z-level value).
%
%\lmt{ui.html} takes care of all other things. Especially it handles all pop-up windows, dialog screens and tool bars.
%This uses heavily the features of jQuery UI, to show and hide the elements in the HTML DOM that represent the dialog boxes.
%
%
%
%The communication with the server is handled by the \lmt{com} object.
%This is a collection of event handler function objects, that send and get data to the server in the background using the interface described in \secref{iface_c_s}.
%
%Upon receiving data, it is stored and then the app is notified by firing the according event. Receiving data is implemented with pulling. (A web server has no means of initiating a data transfer to a particular client) Pulling describes the technique of repeatedly querying the server, if new data is around.
%
%
%Data sources modules
%
%\spl can load it's data from different data sources.
%Those data sources are implemented as member objects of the plain object \lmt{datasources}.
%Each data source object has a corresponding server side class.
%Data source objects are initialized if selected in the initial dialog.
%They are supposed to populate \lmt{datasource} with their data and can make use of \lmt{ui.html.GenericDatasourceDialog}, that gets designed by the server side template.
%
%They have to register an event handler for \evt{LensesSelected}.
%This event gets fired, when the user clicks on OK in the custom \C{GenericDatasourceDialog}.
%The event handler can be used to determine the database model id in combination with the server side part of the data source module (by either creating a new database entry or returning an existing one). This communication bypasses the \lmt{com} object and uses its own api \T{datasourceApi}.
%Once the id of the model to be loaded is determined, the data source module is expected to return control to the main app by firing \evt[models]{GetModelData}, where \str{models} is an array of model ids to load.
%
%Alternatively, this process can be skipped by starting up the web application with a known, existing model id using \T{GET} parameter \T{mid}\footnote{\splurl[?mid=42]} or by loading an existing result using the result id \T{GET} parameter \T{rid}\footnote{\splurl[?rid=1337]}.
%
%
%
